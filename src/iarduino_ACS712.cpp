#include "iarduino_ACS712.h"															//
//		Объявление экземпляра класса			([адрес модуля])						//
		iarduino_ACS712::iarduino_ACS712		(uint8_t i){pinSensor=i;}				//
																						//
//		Чтение постоянного тока:														//
float	iarduino_ACS712::readDC					(uint8_t i){							//	Аргумент: коэффициент сглаживания показаний
			uint32_t j=millis();														//	Читаем время вызова данной функции
			if(i==0){																	//	Если требуется автоматическое сглаживание показаний, то ...
				if(timeDC>j)	{i=50;}else												//	Если прошло переполнение millis(), то считаем что с момента последнего чтения показаний постоянного тока прошло 50 мс
				if(j-timeDC>50)	{i=50;}else												//	Если прошло более 50 мс, то считаем что прошло 50 мс
								{i=j-timeDC;}											//	Определяем реальное время прошедшее с момента последнего чтения показаний постоянного тока
				i=(54-i)/2;																//	Определяем коэффициент сглаживания показаний (от 27 при частых запросах, до 2 при редких)
			}																			//	В результате, чем чаще идут запросы на чтение, тем сильнее сглаживание, значит результат будет более стабильным.
			readVDC(i);																	//	Читаем напряжение на выходе модуля сглаживая прочитанное значение на коэффициент i
			timeDC=j;																	//	Сохраняем время вызова данной функции (для следующего рассчёта показаний)
			return (voltageCDC - voltageDC) / sensDC;									//	Возвращаем ток I = (V без тока - V с током) / чуствительность датчика к постоянному току
}																						//
																						//
//		Чтение переменного тока:														//
float	iarduino_ACS712::readAC					(uint8_t i){							//	Аргумент: коэффициент сглаживания показаний
			uint32_t j=millis();														//	Читаем время вызова данной функции
			if(i==0){																	//	Если требуется автоматическое сглаживание показаний, то ...
				if(timeAC>j)	{i=50;}else												//	Если прошло переполнение millis(), то считаем что с момента последнего чтения показаний переменного тока прошло 50 мс
				if(j-timeAC>50)	{i=50;}else												//	Если прошло более 50 мс, то считаем что прошло 50 мс
								{i=j-timeAC;}											//	Определяем реальное время прошедшее с момента последнего чтения показаний переменного тока
				i=(54-i)/2;																//	Определяем коэффициент сглаживания показаний (от 27 при частых запросах, до 2 при редких)
			}																			//	В результате, чем чаще идут запросы на чтение, тем сильнее сглаживание, значит результат будет более стабильным.
			readVAC(i);																	//	Читаем напряжение на выходе модуля сглаживая прочитанное значение на коэффициент i
			timeAC=j;																	//	Сохраняем время вызова данной функции (для следующего рассчёта показаний)
			if(voltageAC-voltageCAC<0){return 0.0f;}									//	Запрещаем выводить отрицательное переменное напряжение
			return (voltageAC - voltageCAC) / sensAC;									//	Возвращаем ток I = (V с током - V без тока) / чуствительность датчика к переменному току
}																						//
																						//
//		Чтение постоянного напряжения на выходе модуля при отсутствии тока:				//
float	iarduino_ACS712::getZeroVDC				(void){									//	Аргументы отсутствуют
			float zero=0; voltageDC=0;													//	Определяем переменныую для вычисления текущего усреднённого напряжения на выходе модуля и сбрасываем предыдущее значение прочитанного напряжения
			for(uint16_t j=0; j<50; j++){												//	Выполняем цикл чтений показаний 50 раз
				readVDC(1,100);															//	Читаем постоянное напряжение с минимальным сглаживанием выполяя 100 выборок
				zero += voltageDC;														//	Получаем сумму всех напряжений (всего из будет 50 шт)
			}   zero /= 50.0f;															//	Получаем среднее напряжение деля сумму на количество
			return zero;																//	Возвращаем среднее напряжение
}																						//
																						//
//		Чтение переменного напряжения на выходе модуля при отсутствии тока:				//
float	iarduino_ACS712::getZeroVAC				(void){									//	Аргументы отсутствуют
			voltageAC=0;																//	Сбрасываем предыдущее значение прочитанного напряжения (если оно было прочитано)
			readVAC(1,10);																//	Читаем переменное напряжение с минимальным сглаживанием выполяя 10 выборок
			return voltageAC;															//	Возвращаем среднее напряжение
}																						//
																						//
//		Установка коррекции смещения нуля для постоянного тока:							//
void	iarduino_ACS712::setZeroVDC				(float i){voltageCDC=i;}				//	Аргумент: постоянное напряжение на выходе модуля при отсутсвии тока
																						//
//		Установка коррекции смещения нуля для переменного тока:							//
void	iarduino_ACS712::setZeroVAC				(float i){voltageCAC=i;}				//	Аргумент: переменное напряжение на выходе модуля при отсутсвии тока
																						//
//		Калибровка показаний модуля для постоянного тока:								//
void	iarduino_ACS712::calibrationDC			(uint16_t i){							//	Аргумент: коэффициент от 0 до 1023 для корректировки показаний силы тока
			if(i>1023){i=1023;} i=1024-i;												//	Требуется обратное значение i, что бы увеличесние коэффициента приводило к увеличению показаний силы тока
			sensDC=i/3909.7169f;														//	Преобразуем i от диапазона 0...511...1023 к диапазону 0 ... 0,1307 ... 0,2640. Делим i на коэффициент K = 511/0,1307 = 3909,7169
}																						//	Значение 0,1307 участвующее в рассчёте коэффициента K, является средей чуствительностью Trema-модулей: 1A = 0,1307В
																						//
//		Калибровка показаний модуля для переменного тока:								//
void	iarduino_ACS712::calibrationAC			(uint16_t i){							//	Аргумент: коэффициент от 0 до 1023 для корректировки показаний силы тока
			if(i>1023){i=1023;} i=1024-i;												//	Требуется обратное значение i, что бы увеличесние коэффициента приводило к увеличению показаний силы тока
			sensAC=i/902.03f;															//	Преобразуем i от диапазона 0...511...1023 к диапазону 0 ... 1,7138 ... 3,4276. Делим i на коэффициент K = 511/0,5665 = 902,03
			sensAC*=0.1307f;															//  Значение 0,1307 участвующее в рассчёте чуствительности sensAC, является средей чуствительностью Trema-модулей: 1A = 0,1307В
}																						//	Значение 0,5665 участвующее в рассчёте коэффициента K, показывает на сколько упало напряжение на выходе модуля, при прохождении через его RC фильтр
																						//
//		Чтение постоянного напряжения													//
void	iarduino_ACS712::readVDC				(uint8_t i, uint8_t j){					//	Аргументы: i - коэффициент сглаживания показаний, j - количество выборок показаний
			if(i==0){i=1;}																//	Коэффициент сглаживания показаний не может быть равен 0
			for(uint8_t k=0; k<j; k++){													//	Читаем показания j раз подряд
				voltageDC *= float(k==0? i:100)-1;										//	Сглаживаем
				voltageDC += float(analogRead(pinSensor)) / ADC_SCALE * VREF;			//	Добавляем прочитанное напряжение: V = значение АЦП / диапазон АЦП * опорное напряжение АЦП
				voltageDC /= float(k==0? i:100);										//	Сглаживаем
			}																			//
}																						//
																						//
//		Чтение переменного напряжения													//
void	iarduino_ACS712::readVAC				(uint8_t i, uint8_t j){					//	Аргументы: i - коэффициент сглаживания показаний, j - количество выборок показаний
			uint16_t minADC, maxADC, thisADC;											//	Объявляем переменные для хранения значений АЦП
			uint32_t m;																	//	Объявляем переменную для хранения времени
			if(i==0){i=1;}																//	Коэффициент сглаживания показаний не может быть равен 0
			for(uint8_t k=0; k<j; k++){													//	Читаем показания j раз подряд
				m=millis();																//	Читаем время начала прохода цикла 
				minADC=ADC_SCALE;														//	Присваиваем переменной максимальное значение АЦП
				maxADC=0;																//	Присваиваем переменной минимальное  значение АЦП
				while (millis()-m < 20){												//	Выполняем цикл не менее 20 мс, это период для сетевой частоты 50 Гц (F = 1/50 = 0.020 c)
					thisADC = analogRead(pinSensor);									//	Читаем текущий уровень напряжения на выходе модуля
					if(thisADC > maxADC){ maxADC = thisADC; }else						//	Определяем максимальное значение АЦП
					if(thisADC < minADC){ minADC = thisADC; }							//	Определяем минимальное  значение АЦП
				}																		//
				voltageAC *= float(k==0? i:100)-1;										//	Сглаживаем
				voltageAC += float(maxADC-minADC) / 2.0 / ADC_SCALE * VREF * 0.7071f;	//	Добавляем прочитанное напряжение: V = амплитуда АЦП / диапазон АЦП * опорное напряжение АЦП * (1/√2)
				voltageAC /= float(k==0? i:100);										//	Сглаживаем
			}																			//
}																						//
